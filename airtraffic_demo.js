//////////////////////////////////////////////////////////////////////////////
// GIS Air Traffic Control Demo: an example of using the GLG Map Server
// integrated in the GLG drawing.
//
// The demo is written in pure HTML5 and JavaScript. The source code of the
// demo uses the GLG Toolkit JavaScript Library supplied by the included
// Glg*.js and GlgToolkit*.js files. The GLG library loads a GLG drawing
// and renders it on a web page, providing an API to handle user interaction
// with graphical objects in the drawing.
//
// The drawings are created using the GLG Graphics Builder, an interactive
// editor that allows to create grahical objects and define their dynamic
// behavior without any programming. The airplane icons are dynamic
// GLG objects created with the Graphics Builder.
//
// The background map is generated by the GLG Map Server, which is integrated
// inside of a GLG drawing as a GLG GIS Object. The GIS Object takes a
// complete care of the map display, automatically generating Map Server
// requests to re-generate the image when the map is panned or zoomed.
//
// The demo demonstrates the use of the asynchronous map loading reques API
// to load a map: when the map is zoomed or  scrolled, the program will continue
// to operate in the old zoom or pan state and will switch to the new zoom or
// pan state when the new map is ready. The GIS Air Traffic Monitoring Demo
// demonstrates an alternative approach that changes the drawing to the new zoom
// or pan state right away, while the new map will appear when it's loaded.
// The USE_REQUEST variable in the code below may be used to change the map
// loading behavior of this demo.
//
// Except for the changes to comply with the JavaScript syntax, this source
// is identical to the source code of the corresponding C/C++/C# and Java
// desktop versions of the demo.
//
// This demo uses the GLG Map Server to display a map.
// The Map Server has to be installed either on the local host or on a
// remote web server. After the Map Server has been installed, modify the
// source code to set the SuppliedMapServerURL variable to point to the
// Map Server location.
//////////////////////////////////////////////////////////////////////////////

// Get a handle to the GLG Toolkit library.
var GLG = new GlgToolkit();

// Debugging aid: uncomment the next line to throw an exception on a GLG error.
//GLG.ThrowExceptionOnError( true, true, true );

// Set initial size of the drawing.
SetDrawingSize( false );

// Increase canvas resolution for mobile devices.
var CoordScale = SetCanvasResolution();

/* Loads all drawings used by the program and invokes the LoadDrawing function
   when done.
*/
LoadAssets( LoadDrawing );

//////////////////////////////////////////////////////////////////////////////
function LoadDrawing()
{
   /* Load a drawing from the airtraffic.g file. 
      The LoadCB callback will be invoked when the drawing has been loaded.
   */
   var drawing_file = ( "mapserver.g" );
   
   GLG.LoadWidgetFromURL( drawing_file, null, LoadCB, null );
}

//////////////////////////////////////////////////////////////////////////////
function LoadCB( drawing, data, path )
{
   if( drawing == null )
   {
      window.alert( "Can't load drawing, check console message for details." );
      return;
   }
                
   var loader = document.getElementById( "loader_container" );
   if( loader )
     loader.parentNode.removeChild( loader );

   // Define the element in the HTML page to display the drawing in.
   drawing.SetParentElement( "glg_area" );

   // Disable viewport border to use the border of the glg_area.
   drawing.SetDResource( "LineWidth", 0 );
    
   StartAirtrafficDemo( drawing );
}

//////////////////////////////////////////////////////////////////////////////
// Control variables and constants
//////////////////////////////////////////////////////////////////////////////

/* This demo uses the GLG Map Server to display a map.
   The Map Server has to be installed either on the local host or on a
   remote web server. After the Map Server has been installed, set the 
   SuppliedMapServerURL variable to point to the Map Server location:

   For example on Linux:
     SuppliedMapServerURL = "http://localhost/cgi-bin/GlmScript";
   or
     SuppliedMapServerURL = "http://www.myserver.com/cgi-bin/GlmScript";

   On Windows:
     SuppliedMapServerURL = "http://localhost/Scripts/GlmScript.pl";
   or
     SuppliedMapServerURL = "http://www.myserver.com/Scripts/GlmScript.pl";

   The SuppliedMapServerURL value overrides the URL of the GIS object in the
   drawing.
*/
var SuppliedMapServerURL = null;    /* String */
 
/* Set to true to use asynchronous map requests to load the new map: when the
   map is zoomed or scrolled, the program will continue to operate in the old
   zoom or pan state and will switch to the new zoom or pan when the new map
   is ready.      
   
   If set to false, the map settings will change to the new zoom or pan state 
   right away, and no map will be displayed while the new map is being loaded.
*/
var USE_REQUEST = true;

// Controls the plane speed used to simulate moving airplanes.
var PlaneSpeed = 0.002;    // Relative units   

var FloridaZoomDelay1 = 4000; // Delay to zoom to Florida to show details.
var FloridaZoomDelay2 = 1000; // Delay to remove Florida zooming message.

/* Set to true to use the orthographic projection instead of switching to the
   rectangular projection for zoomed maps.
*/
var OrthoOnly = false;

/* Defines an action to perform on touch on mobile devices: 
   select airplane or scroll the map.
*/
var ScrollMode;

// Constants
const
   MAX_NUM_PLANES = 10000,
   NUM_NODE_TYPES = 2,
   NUM_PLANE_TYPES = 3;

const
   SMALL_SIZE  = 1.0,
   MEDIUM_SIZE = 1.5,
   BIG_SIZE    = 2.0;

const
   SMALL_MARKER_SIZE  = 7.0,
   MEDIUM_MARKER_SIZE = 9.0,
   BIG_MARKER_SIZE    = 11;

const
   NORMAL = 0,
   WARNING = 1,
   ALARM = 2,
   SELECTED = 3;

var NodePool = new Array( NUM_NODE_TYPES );
var PlanePool = new Array( NUM_PLANE_TYPES );
var NodeTemplate = new Array( NUM_NODE_TYPES );
var PlaneTemplate = new Array( NUM_PLANE_TYPES );

var
   Drawing,                       /* GlgObject */
   PositionObject,                /* GlgObject */
   PositionArea,                  /* GlgObject */
   TrajectoryTemplate,            /* GlgObject */
   TrajectoryPool,                /* GlgObject */
   Map,                           /* GlgObject */
   FlightInfoPopup,               /* GlgObject */
   GISObject,                     /* GlgObject */
   GISArray,                      /* GlgObject */
   NodeGroup,                     /* GlgObject */
   PlaneGroup,                    /* GlgObject */
   TrajectoryGroup,               /* GlgObject */
   DistancePolygon;               /* GlgObject */

// GlgPoints, store initial extent and center used to reset zoom.
var
   InitExtent = GLG.CreateGlgPoint( 0, 0, 0 ),   /* GlgPoint */
   InitCenter = GLG.CreateGlgPoint( 0, 0, 0 );   /* GlgPoint */

// String type
var
   BaseLayers,                    /* String */
   NewBaseLayers,                 /* String */
   NewLayers,                     /* String */
   RequestType;                   /* String */

var PlaneSize = SMALL_SIZE;       /* double */

var
   MapProjection,                 /* int */
   NewMapProjection;              /* int */

var
   NewExtent = GLG.CreateGlgPoint( 0, 0, 0 ),   /* GlgPoint */
   NewCenter = GLG.CreateGlgPoint( 0, 0, 0 );   /* GlgPoint */

var
   UpdateInterval = 50,           /* int - update interval in msec. */
   NumPlanes = 100,               /* int - number of planes to use in the demo */
   NumNodes,                      /* int */
   NumTrajectoryPoints,           /* int */
   PlaneType = 0,                 /* int */
   NodeType = 0,                  /* int */
   SelectedPlaneIndex = -1,       /* int */
   NumDistancePoints;             /* int */

var NewFlags = GLG.GlgGISRequestFlags.GIS_REQUEST_NOTHING;  /* int */

   
/* Don't change: must always be false for initial map loading, will be set to 
   the value of USE_REQUEST after that.
   Change USE_REQUEST above to use asynchronous map requests.
*/
var UseRequest = false;

var
   MapLoaded = false,             /* boolean */
   InitialLoad = true,            /* boolean */
   PerformUpdates = true,         /* boolean */
   PanMode = false,               /* boolean */
   DistanceMode = false,          /* boolean */
   HasAngle = false,              /* boolean */
   HasElevation = false,          /* boolean */
   CityLabels = true,             /* boolean */
   StateDisplay = true,           /* boolean */
   DraggingFromButton = false,    /* boolean */
   NewCityLabels,                 /* boolean */
   NewCityLabelsFlag = false;     /* boolean */
   
var PlaneArray;                   /* Array */

/* Array of icons to place on the map as GLG objects in addition to the icons
   defined in GIS server's data. The icons that use GLG objects may be 
   selected with the mouse and their attributes can be changed dynamically, 
   based on data. When the mouse moves over an icon, it may be highlighted 
   with a different color or a tooltip may be displayed. 
*/
var NodeArray =
  [ new NodeData( "Boston",        -71.01789,  42.33602 ),
    new NodeData( "New York",      -73.97213,  40.77436 ),
    new NodeData( "San Francisco", -122.55478, 37.79325 ),
    new NodeData( "Miami",         -80.21084,  25.77566 ),
    new NodeData( "Seattle",       -122.35032, 47.62180 ),
    new NodeData( "Houston",       -95.38672,  29.76870 ),
    new NodeData( "Denver",        -104.87265, 39.76803 ),
    new NodeData( "Minneapolis",   -93.26684,  44.96185 ),
    new NodeData( "Chicago",       -87.68496,  41.83705 ),
    new NodeData( "Dallas",        -96.76524,  32.79415 ) ];

var gis_request_observer;

// Temporary variables: allocate once
var
   lat_lon  = GLG.CreateGlgPoint( 0, 0, 0 ),   /* GlgPoint */
   point    = GLG.CreateGlgPoint( 0, 0, 0 ),   /* GlgPoint */
   last_xyz = GLG.CreateGlgPoint( 0, 0, 0 ),   /* GlgPoint */
   curr_xyz = GLG.CreateGlgPoint( 0, 0, 0 );   /* GlgPoint */

var timer = null;
var zoom_timer = null;

//////////////////////////////////////////////////////////////////////////////
function StartAirtrafficDemo( drawing )
{
   Drawing = drawing;

   InitDrawing();
   InitIcons();

   Drawing.SetupHierarchy();

   AddIcons();    // After the hierarchy setup.
   Drawing.Update();

   /* After the GIS object has been drawn the first time, we can switch
      to using asynchronous requests for loading GIS images if requested
      by the USE_REQUEST setting.
   */
   UseRequest = USE_REQUEST;
   if( UseRequest )
   {
      gis_request_observer =
        GLG.CreateGlgGISRequestObserver( RequestUpdate, RequestAdjustment,
                                         AdjustRequest );

      GISObject.SetScrollbarObserver( null, gis_request_observer );
   }
   
   timer = setTimeout( UpdatePlanes, UpdateInterval );

   // Zoom to the Florida area after a few seconds to show details.        
   zoom_timer = setTimeout( ZoomToFlorida, FloridaZoomDelay1 );
}

//////////////////////////////////////////////////////////////////////////////
function InitDrawing()
{
   // Show mouse over tooltips right away.
   Drawing.SetDResource( "$config/GlgMouseTooltipTimeout", 0.05 );

   Map = Drawing.GetResourceObject( "Map" );   
   FlightInfoPopup = Map.GetResourceObject( "FlightInfoPopup" );
   GISObject = Map.GetResourceObject( "GISObject" );

   if( SuppliedMapServerURL != null )
     // Override the URL defined in the drawing.
     GISObject.SetSResource( "GISMapServerURL", SuppliedMapServerURL );

   // Query and store GIS object's Extent and Center.
   InitExtent = GISObject.GetGResource( "GISExtent" );
   InitCenter = GISObject.GetGResource( "GISCenter" );

   // Query and store the GIS projection (ORTHOGRAPHIC or RECTANGULAR)
   MapProjection = Math.trunc( GISObject.GetDResource( "GISProjection" ) );

   /* Set the GIS Zoom mode. It was set and saved with the drawing, 
      but do it again programmatically just in case.
   */
   Map.SetZoomMode( null, GISObject, null, GLG.GlgZoomMode.GIS_ZOOM_MODE );

   /* Get ID of the GIS Object's GISArray, which holds all icons displayed
      on top of the map in lat/lon coordinates.
   */
   GISArray = GISObject.GetResourceObject( "GISArray" );

   // Make popup dialog and distance popup invisible.
   FlightInfoPopup.SetDResource( "Visibility", 0.0 );
   Map.SetDResource( "DistancePopup/Visibility", 0.0 );

   /* Disable the color button: this functionality is not supported with
      the remote map sever setup.
   */
   Drawing.SetDResource( "ToggleColor/HandlerDisabled", 1.0 );	  
   
   /* Add Input and Trace callbacks used to handle user interaction. */
   Drawing.AddListener( GLG.GlgCallbackType.INPUT_CB, InputCallback );
   Drawing.AddListener( GLG.GlgCallbackType.TRACE_CB, TraceCallback );
}

//////////////////////////////////////////////////////////////////////////
// Initializes icons in the drawing
//////////////////////////////////////////////////////////////////////////
function InitIcons()
{
   var icon_name;
   var i;

   // Get the palette containing templates for plane and node icons.
   var palette = Drawing.GetResourceObject( "Palette" );

   // Delete it from the drawing
   Drawing.DeleteThisObject( palette );

   /* Get node and plane templates from the palette. A few sets of templates
      with different level of details are used, depending on the zoom level.
      Palette aproach is used to implement icon types instead of 
      subdrawings, since icons are dynamically added/deleted from the 
      drawing any way to show only the icons visible in the zoomed area.
   */
   for( i=0; i < NUM_PLANE_TYPES; ++i )
   {
      icon_name = "Plane" + i;
      PlaneTemplate[ i ] = palette.GetResourceObject( icon_name );

      // Turn labels on initially. 
      if( PlaneTemplate[ i ].GetResourceObject( "Label" ) != null )
        PlaneTemplate[ i ].SetDResource( "Label/Visibility", 1.0 );
   }

   TrajectoryTemplate = palette.GetResourceObject( "Trajectory" );
   NumTrajectoryPoints =
     Math.trunc( TrajectoryTemplate.GetDResource( "Factor" ) );

   /* Small filled circles don't look nice in a native renderer.
      Add EDGE to make them look nicer.   
   */
   TrajectoryTemplate.SetDResource( "Marker/MarkerType", 
                                    ( GLG.GlgMarkerType.FILLED_CIRCLE |
                                      GLG.GlgMarkerType.CIRCLE ) );
   
   for( i=0; i < NUM_NODE_TYPES; ++i )
   {
      icon_name = "Node" + i;
      NodeTemplate[ i ] = palette.GetResourceObject( icon_name );
   }

   NumNodes = NodeArray.length;

   // Create and initialize plane structures used for simulation.
   PlaneArray = new Array( NumPlanes );
   for( i =0; i < NumPlanes; ++i )
   {
      var plane = new PlaneData();
      plane.name = i.toString();
      plane.color_index = NORMAL;
      PlaneArray[ i ] = plane;
      
      StartPlane( PlaneArray[ i ], true );
   }

   // Create groups to hold nodes and planes.
   NodeGroup = GLG.CreateObject( GLG.GlgObjectType.ARRAY,
                                 GLG.GlgContainerType.GLG_OBJECT, 0, 0, null );
   NodeGroup.SetSResource( "Name", "NodeGroup" );

   TrajectoryGroup =
     GLG.CreateObject( GLG.GlgObjectType.ARRAY,
                       GLG.GlgContainerType.GLG_OBJECT, 0, 0, null );
   TrajectoryGroup.SetSResource( "Name", "TrajectoryGroup" );

   PlaneGroup =
     GLG.CreateObject( GLG.GlgObjectType.ARRAY,
                       GLG.GlgContainerType.GLG_OBJECT, 0, 0, null );
   PlaneGroup.SetSResource( "Name", "PlaneGroup" );

   /* Add all icons to the GIS object, so that the icon's position may be
      defined in lat/lon. The GIS object handles all details of the 
      GIS coordinate conversion.
   */
   GISObject.AddObjectToBottom( NodeGroup );
   GISObject.AddObjectToBottom( PlaneGroup );
   GISObject.AddObjectToBottom( TrajectoryGroup );

   /* Create groups to keep pooled object icons. Only the icons visible in the
      current view are displayed. Any not used icons are stored in the icon pool.
   */
   for( i=0; i<NUM_NODE_TYPES; ++i )
     NodePool[i] =
       GLG.CreateObject( GLG.GlgObjectType.ARRAY,
                         GLG.GlgContainerType.GLG_OBJECT, 0, 0, null );
   
   for( i=0; i<NUM_PLANE_TYPES; ++i )
     PlanePool[i] =
       GLG.CreateObject( GLG.GlgObjectType.ARRAY,
                         GLG.GlgContainerType.GLG_OBJECT, 0, 0, null );
      
   TrajectoryPool =
     GLG.CreateObject( GLG.GlgObjectType.ARRAY,
                       GLG.GlgContainerType.GLG_OBJECT, 0, 0, null );

   SetPlaneSize();

   /* The demo starts with the whole word view, then zooms to the Florida area
      in a few seconds to show more details. Set initial parameters
      for the whole world view.
      */
   SetupZoomLayers( null );

   RequestNewMap( false, false );

   // Store objects used to display lat/lon on mouse move.
   PositionArea = Drawing.GetResourceObject( "PositionArea" );
   PositionObject = Drawing.GetResourceObject( "PositionLabel/String" );
   PositionObject.SetSResource( null, "" );

   // Set Florida zooming message to OFF initially.
   Drawing.SetDResource( "Map/FloridaZoomingMessage/Visibility", 0.0 );
}

//////////////////////////////////////////////////////////////////////////
// Invoked after the hierarchy setup.
//////////////////////////////////////////////////////////////////////////
function AddIcons()
{
   // Add visible icons to the drawing and handle zoom level.
   UpdateObjectsOnMap( false );

   SetMapLoading( true, "Loading map..." );
}

//////////////////////////////////////////////////////////////////////////
function SetMapLoading( show, message )
{
   if( show )
   {
      SetStatus( message );
      Map.SetSResource( "LoadingMessage/String", message );
      Map.SetDResource( "LoadingMessage/Visibility", 1 );
      MapLoaded = false;
   }
   else
   {
      SetStatus( "" );
      Map.SetDResource( "LoadingMessage/Visibility", 0 );
      MapLoaded = true;
   }
}

//////////////////////////////////////////////////////////////////////////
// Makes sure the icons visible at the current zoom level are added
// to the drawing, keeping the rest of the icons in the object pool.
// Also handles the use of more detailed icons depending on the zoom 
// level.
// The object pools are used to handle huge number of icons efficiently.
// For a smaller number of icons, icons may always be kept in the drawing
// and this function is not needed.
//////////////////////////////////////////////////////////////////////////
function UpdateObjectsOnMap( using_request )
{
   var i;
   
   // Delete old nodes and planes.
   DeleteNodes();
   DeletePlanes();
   
   // When using a request, SetupZoomLayers was invoked from AdjustRequest.
   if( !using_request )
   {
      SetupZoomLayers( null );
      if( NewFlags != 0 )
        RequestNewMap( false, false );  // Flush changes into the map.
   }

   SetupZoomIcons();

   /* Update the GIS object with new extent but don't draw it yet:
      we want to position icons on the map first.
   */
   Map.SetupHierarchy();
   
   for( i = 0; i < NumNodes; ++i )      // Position nodes
     PositionNode( NodeArray[ i ], i );

   /* Add trajectories before positioning planes to setup trajectories' 
      history.
   */
   GISObject.AddObjectToBottom( TrajectoryGroup );
   
   for( i = 0; i < NumPlanes; ++i )     // Position planes
     PositionPlane( PlaneArray[ i ], i );
   
   // Add new nodes and planes.
   GISObject.AddObjectToBottom( NodeGroup );
   GISObject.AddObjectToBottom( PlaneGroup );
   
   SelectPlane( SelectedPlaneIndex );
}

//////////////////////////////////////////////////////////////////////////
// Set displayed layers depending on zoom level. 
// Also change to rectangular projection for high zoom factors.
//////////////////////////////////////////////////////////////////////////
function SetupZoomLayers( request_data )
{
   var base_layers;      /* String */
   var city_labels;      /* boolean */
   
   if( request_data == null )
     FlushMapChanges();
   
   var extent = GetExtentDegrees( request_data );   /* GlgPoint */

   if( extent.x < 70.0 && extent.y < 70.0 )
   {
      base_layers = "default_air";
      city_labels = true;     // Use city names instead of airport labels.
   }
   else    // Whole world view 
   {
      base_layers = "default_gis,grid70,outline";
      city_labels = false;   // Use airport labels instead of all city names.
   }
   
   // Adjust if changed.
   if( base_layers != BaseLayers || city_labels != CityLabels )
   {
      var layers = CreateLayerString( base_layers, city_labels );
      
      if( request_data != null )
      {
         /* Adjust layers in request data. */
         request_data.layers = layers;
      }
      else
      {
         NewLayers = layers;
         NewFlags |= GLG.GlgGISRequestFlags.GIS_REQUEST_LAYERS;
      }
      
      NewBaseLayers = base_layers;
      NewCityLabels = city_labels;
      NewCityLabelsFlag = true;
   }

   if( !OrthoOnly )
     ChangeProjection( request_data );
}

////////////////////////////////////////////////////////////////////////
// Add map layers: airport/city labels and states.
////////////////////////////////////////////////////////////////////////
function CreateLayerString( base_layers, city_labels )
{
   var layers = base_layers;
   
   if( city_labels )
     layers += ",us_cities";
   else
     layers += ",-us_cities";
   
   if( StateDisplay )   // Add states layer if it is on.
     // Enable states regardless of the default.
     layers += ",states_dcw";
   else
     // Disable state outline display.
     layers += ",-states_dcw";
   
   return layers;
}

////////////////////////////////////////////////////////////////////////
function SetGISLayers()
{
   NewLayers = CreateLayerString( BaseLayers, CityLabels );
   NewFlags = GLG.GlgGISRequestFlags.GIS_REQUEST_LAYERS;
   
   RequestNewMap( false, true );
}

//////////////////////////////////////////////////////////////////////////
// Set node types depending on the zoom level.
//////////////////////////////////////////////////////////////////////////
function SetupZoomIcons()
{
   var extent = GetExtentDegrees( null );   /* GlgPoint */

   if( extent.x < 20.0 && extent.y < 20.0 )
   {
      // High Zoom: use the most detailed icon.
      NodeType = 1;
      PlaneType = 2;         // Most detailed icon
      HasAngle = true;       // Most detailed plane icons show angle
      HasElevation = true;   // Most detailed plane icons show elevation
   }
   else if( extent.x < 70.0 && extent.y < 70.0 )
   {
      // Zoom: use detailed icon 1 
      NodeType = 1;
      PlaneType = 1;         // Detailed icon 
      HasAngle = true;       // Detailed plane icons show angle 
      HasElevation = false;  
   }
   else
   {
      // Whole world view 
      NodeType = 1;          // City icons are always visible 
      PlaneType = 0;         // Simple icon 
      HasAngle = false;
      HasElevation = false;
   }
   
   // Airport labels should be visible only when city labels are off.
   NodeTemplate[1].SetDResource( "Label/Visibility", CityLabels ? 0.0 : 1.0 );
}

//////////////////////////////////////////////////////////////////////////
// Change projection to rectangular for zoomed views, and back to 
// orthographics for high-level views.
//////////////////////////////////////////////////////////////////////////
function ChangeProjection( request_data )
{
   var projection = GetMapProjection( request_data );

   var extent = GetExtentDegrees( request_data );   /* GlgPoint */
   if( extent.x < 30.0 && extent.y < 30.0 )
   {
      if( projection == GLG.GlgProjectionType.RECTANGULAR_PROJECTION )
        return;    // Already rectangular, no change.
      
      // Change to the rectangular projection, extent is already in degrees.
      projection = GLG.GlgProjectionType.RECTANGULAR_PROJECTION;
   }
   else
   {
      if( projection == GLG.GlgProjectionType.ORTHOGRAPHIC_PROJECTION )
        return;    // Already ortho, no change
      
      // Change to the orthographic projection
      projection = GLG.GlgProjectionType.ORTHOGRAPHIC_PROJECTION;
      
      // Change extent to meters
      extent.x = extent.x / 90.0 * GLG.EQUATOR_RADIUS;
      extent.y = extent.y / 90.0 * GLG.POLAR_RADIUS;
   }
   
   if( request_data != null )
   {
      // Adjust projection and extent in request data.
      request_data.projection = projection;
      request_data.extent = extent;  // Set extent in degrees
   }
   else
   {
      NewMapProjection = projection;
      NewExtent = extent;  // Set extent in degrees
      NewFlags |= ( GLG.GlgGISRequestFlags.GIS_REQUEST_PROJECTION | 
                    GLG.GlgGISRequestFlags.GIS_REQUEST_EXTENT );
   }
}

//////////////////////////////////////////////////////////////////////////
// Handle user interaction.
//////////////////////////////////////////////////////////////////////////
function InputCallback( viewport, message_obj )
{
   var origin = message_obj.GetSResource( "Origin" );
   var format = message_obj.GetSResource( "Format" );
   var action = message_obj.GetSResource( "Action" );
   var subaction = message_obj.GetSResource( "SubAction" );

   if( format == "Button" )         // Handle button clicks
   {
      if( action != "Activate" )
        return;
      
      PanMode = false;       // Abort Pan mode

      if( DistanceMode )           
      {
         AbortDistanceMode();  // Abort the distance mode in progress.

         // Second click on the Distance button: cancel DistanceMode in progress.
         if( origin == "Distance" )
           return;
      }

      AbortDistanceMode();
      
      if( origin == "CloseDialog" )
      {
         Drawing.SetDResource( "SelectionDialog/Visibility", 0.0 );
         Drawing.Update();	 
      }
      else if( origin == "Up" )
      {	    
         Zoom( 'u', 0.0 );
      }
      else if( origin == "Down" )
      {	    
         Zoom( 'd', 0.0 );
      }
      else if( origin == "Left" )
      {	    
         Zoom( 'l', 0.0 );
      }
      else if( origin == "Right" )
      {	    
         Zoom( 'r', 0.0 );
      }
      else if( origin == "ZoomIn" )
      {
         Zoom( 'i', 2.0 );
      }
      else if( origin == "ZoomOut" )
      {
         Zoom( 'o', 2.0 );
      }
      else if( origin == "ZoomReset" )
      {	
         Zoom( 'n', 0.0 );
      }
      else if( origin == "ZoomTo" )
      {
         Zoom( 't', 0.0 );
      }
      else if( origin == "Pan" )
      {	    
         Map.SetZoom( null, 'e', 0.0 );  // Abort ZoomTo/Drag mode
         
         PanMode = true;
         SetStatus( "Click to define a new center." );
         Drawing.Update();	 
      }
      else if( origin == "Drag" )
      {
         /* Activate dragging mode. Dragging will start on the mouse click. 
            If no object of interest is selected by the mouse click, 
            dragging will be started by the code in the Trace callback 
            anyway, but only if no object of interest was selected. 
            The "Drag" button demostrates an alternative way to start 
            dragging from a button which starts dragging even if an object 
            of interest is selected by the mouse click.
         */
         DraggingFromButton = true;
         Zoom( 's', 0.0 );
         SetStatus( "Click and drag the map with the mouse." );
         Drawing.Update();
      }
      else if( origin == "AirportLabels" )
      {
         CityLabels = !CityLabels;
         SetGISLayers();
      }
      else if( origin == "ToggleStates" )
      {
         StateDisplay = !StateDisplay;
         SetGISLayers();
      }
      else if( origin == "Planes" )
      {
         ToggleResource( Map, "PlaneGroup/Visibility" );
         Drawing.Update();	 
      }
      else if( origin == "ValueDisplay" )
      {
         if( PlaneType == 0 )
         {
            GLG.Bell();
            SetStatus( "Zoom in to see plane labels." );
         }
         else
         {
            // Visibility of all labels is constrained, set just one.
            for( var i=1; i<NUM_PLANE_TYPES; ++i )
              ToggleResource( PlaneTemplate[ i ], "Label/Visibility" );
         }
         Drawing.Update();	 
      }
      else if( origin == "Update" )
      {
         PerformUpdates = !PerformUpdates;
         Drawing.Update();
      }	
      else if( origin == "PlaneSize" )
      {
         // Change plane icon's size.
         if( PlaneSize == SMALL_SIZE )
           PlaneSize = MEDIUM_SIZE;
         else if( PlaneSize == MEDIUM_SIZE )
           PlaneSize = BIG_SIZE;
         else // BIG_SIZE
           PlaneSize = SMALL_SIZE;	 
         
         SetPlaneSize();
         
         Drawing.Update();	 
      }
      else if( origin == "CloseFlightInfo" )
      {
         SelectPlane( -1 ); // Unselect the plane and erase popup display.
         Drawing.Update();	 
      }	
      else if( origin == "Distance" )
      {
         DistanceMode = true;
         SetStatus( "Click on the map to define distance to measure, press the button again or right click to finish." );
         Drawing.Update();
      }
   }
   /* Process mouse clicks on plane icons, implemented as an Action with
      the Plane label attached to an icon and activated on a mouse click. 
   */
   else if( format == "CustomEvent" )
   {	
      /* Ignore selection in the Distance or DraggingFromButton mode,
         as well as in the Scroll mode on mobile devices.
      */
      if( DistanceMode || DraggingFromButton ||
          ScrollMode && SetDrawingSize.is_mobile )
        return;

      var event_label = message_obj.GetSResource( "EventLabel" );
         
      if( event_label == "Plane" )  // Plane icon was selected
      {
         /* Map dragging mode is activated either on a mouse click in the 
            trace callback, or with the Drag toolbar button. 
            Abort the dragging mode if an object with custom event was 
            selected and the dragging was activated on a mouse click. 
            This gives custom events a higher priority compared to the 
            dragging mode. If it's a ZoomTo mode 
            activated by a button, don't abort it and ignore object selection.
         */
         var zoom_mode = ZoomToMode();
         if( zoom_mode == 0 ||
             ( zoom_mode & GLG.GlgZoomState.PAN_DRAG_STATE ) != 0 )
         {
            if( zoom_mode != 0 )
              Map.SetZoom( null, 'e', 0.0 );  /* Abort zoom mode */
            
            // Get plane index 
            var plane_index =
              Math.trunc( message_obj.GetDResource( "Object/DataIndex" ) );
            SelectPlane( plane_index );
               
            // Show message in the bottom
            SetStatus( PlaneArray[ SelectedPlaneIndex ].tooltip );
               
            DisplayPlaneInfo();   // Display popup
            Drawing.Update();
         }
      }
   }
   else if( action == "Zoom" )
   {
      if( subaction == "End" )
      {
         /* Update icon positions after zooming if not using request.
            If using request, it is done when the request is installed.
         */
         if( !UseRequest )
           UpdateObjectsOnMap( false );
         
         /* Wait for map loading if the request wasn't aborted by an invalid
            ZoomTo rectangle with zero width / height.
         */
         if( GISObject.GetGISRequestInfo( null ) != null )
           SetMapLoading( true, "Loading map..." );

         Drawing.Update();
      }
      else if( subaction == "Abort" )
        SetStatus( "" );
   }
   else if( action == "Pan" )
   {
      if( subaction == "Start" )   // Map dragging start
      {
         SetStatus( "Drag the map with the mouse." );
      }
      else if( subaction == "Drag" )    // Dragging
      {
         DraggingFromButton = false;
         
         /* Update icon positions after zooming if not using request.
            If using request, it is done when the request is installed.
         */
         if( !UseRequest )
         {
            UpdateObjectsOnMap( false );
            SetMapLoading( true, "Loading map..." );
            SetStatus( "Dragging the map with the mouse..." );
         }
         else
           SetMapLoading( true, "Release the mouse to show the new map." );

         Drawing.Update();
      }
      else if( subaction == "ValueChanged" )   // Scrollbars
      {
         /* Update icon positions after scrolling if not using request.
            If using request, it is done when the request is installed.
         */
         if( !UseRequest )
           UpdateObjectsOnMap( false );

         SetMapLoading( true, "Loading map..." );
         Drawing.Update();         
      }
      // Dragging ended or aborted (right mouse button, etc.). 
      else if( subaction == "End" || subaction == "Abort" )
      {
         DraggingFromButton = false;
         if( UseRequest && subaction != "Abort" )
           SetMapLoading( true, "Loading map..." );
         else
           SetMapLoading( false, "" );  // Reset message when dragging ends.
         Map.Update();
      }
   }   
}

//////////////////////////////////////////////////////////////////////////
function ZoomToMode()
{
   return Math.trunc( Map.GetDResource( "ZoomToMode" ) );
}

//////////////////////////////////////////////////////////////////////////
// Is used to obtain coordinates of the mouse click. 
//////////////////////////////////////////////////////////////////////////
function TraceCallback( viewport, trace_info )
{      
   var event_type = trace_info.event_type;
   var x, y;

   // Use the Map area events only.
   if( !trace_info.viewport.Equals( Map ) )
   {
      /* Erase the current postion display when the mouse moves outside 
         of the map.
      */
      switch( event_type )
      {
       case GLG.GlgEventType.MOUSE_MOVED:
         PositionObject.SetSResource( null, "" );
         PositionArea.Update();
         break;
      }
      return;
   }

   switch( event_type )
   {
    case GLG.GlgEventType.KEY_DOWN:
      if( trace_info.event.keyCode == 27 )      // ESC key
        AbortDistanceMode();
      return;

    case GLG.GlgEventType.TOUCH_START:
      if( !DraggingFromButton && !DistanceMode && !ScrollMode )
        return;
      
      GLG.SetTouchMode();        /* Start dragging via touch events. */
      /* Fall through */

    case GLG.GlgEventType.TOUCH_MOVED:
      if( !GLG.GetTouchMode() )
        return;
    case GLG.GlgEventType.MOUSE_PRESSED:
    case GLG.GlgEventType.MOUSE_MOVED:
      x = trace_info.mouse_x * CoordScale;
      y = trace_info.mouse_y * CoordScale;

      /* COORD_MAPPING_ADJ is added to the cursor coordinates for precise
         pixel mapping.
      */
      x += GLG.COORD_MAPPING_ADJ;
      y += GLG.COORD_MAPPING_ADJ;
      break;

    default: return;
   }
 
   var point_obj;    /* GlgObject */

   switch( event_type )
   {
    case GLG.GlgEventType.TOUCH_START:
    case GLG.GlgEventType.MOUSE_PRESSED:
      if( ZoomToMode() != 0 )
        return; // ZoomTo or dragging mode in progress: pass it through.

      if( trace_info.button != 1 )
      {
         AbortDistanceMode();
         return;  // Use only the left button clicks.
      }
      
      /* Handle paning: set the new map center to the location of the click. */
      if( PanMode )
      {
         PanMode = false;
         SetStatus( "" );
         
         // Converts X/Y to lat/lon using GIS object's current projection.
         point.x = x;
         point.y = y;
         point.z = 0.0;
         GISObject.GISConvert( null, GLG.GlgCoordType.SCREEN_COORD,
                               /* X/Y to Lat/Lon */ true, point, lat_lon );
         
         console.log( "x= " + x + " y= " + y );
         console.log( "lon= " + lat_lon.x + " lat= " + lat_lon.y );

         // Pan the map
         NewCenter = GLG.CreateGlgPoint( lat_lon.x, lat_lon.y, 0 );
         NewFlags = GLG.GlgGISRequestFlags.GIS_REQUEST_CENTER;
         RequestNewMap( true, true );
      }
      else if( DistanceMode )
      { 
         /* The world coordinates inside the GIS Object's GISArray are in 
            lat/lon.
         */
         point.x = x;
         point.y = y;
         point.z = 0.0;
         GISArray.ScreenToWorld( true, point, lat_lon );
               
         if( DistancePolygon == null )
         {
            DistancePolygon =
              GLG.CreateObject( GLG.GlgObjectType.POLYGON, 2, null, null, null );
            DistancePolygon.SetGResource( "EdgeColor", 1.0, 1.0, 0.0 );
            NumDistancePoints = 1;

            point_obj = DistancePolygon.GetElement( 0 );
            point_obj.SetGResourceFromPoint( null, lat_lon );
               
            point_obj = DistancePolygon.GetElement( 1 );
            point_obj.SetGResourceFromPoint( null, lat_lon );
               
            GISObject.AddObjectToBottom( DistancePolygon );
            Map.Update();	    
         }
         else // Not the first point
         {
            // Set current point to the coord. of the click.
            point_obj = DistancePolygon.GetElement( NumDistancePoints );
            point_obj.SetGResourceFromPoint( null, lat_lon );
            ++NumDistancePoints;
               
            DisplayDistance( DistancePolygon );
            
            // Add next point, same coords.
            point_obj = point_obj.CopyObject();
            DistancePolygon.AddObjectToBottom( point_obj );
               
            Map.Update();
         }
      }
      else 
        // Not a Pan or Distance mode: start dragging the map with the mouse.
        Zoom( 's', 0.0 );
      break;
      
    case GLG.GlgEventType.TOUCH_MOVED:
    case GLG.GlgEventType.MOUSE_MOVED:
      point.x = x;
      point.y = y;
      point.z = 0;
         
      // The world coordinates inside the GIS Object's GISArray are in lat/lon.
      GISArray.ScreenToWorld( true, point, lat_lon );

      if( DistanceMode && DistancePolygon != null )
      {
         point_obj = DistancePolygon.GetElement( NumDistancePoints );
         point_obj.SetGResourceFromPoint( null, lat_lon );
         DisplayDistance( DistancePolygon );
         Map.Update();
      }

      // Display lat/lon of a point under the mouse.
      PositionObject.SetSResource( null, CreateLocationString( lat_lon ) );
      PositionArea.Update();
      break;
         
    default: return;
   }
}

//////////////////////////////////////////////////////////////////////////
function AbortDistanceMode()
{
   if( DistanceMode )
   {
      if( DistancePolygon != null )   // Delete distance polygon
      {
         if( GISObject.ContainsObject( DistancePolygon ) )
           GISObject.DeleteThisObject( DistancePolygon );
            
         DistancePolygon = null;
      }
      Map.SetDResource( "DistancePopup/Visibility", 0.0 );
      SetStatus( "" );
      DistanceMode = false;
   }
}

//////////////////////////////////////////////////////////////////////////
function DisplayDistance( /* GlgObject */ polygon )
{
   // Popup distance display
   Map.SetDResource( "DistancePopup/Visibility", 1.0 );
      
   // Last point is for dragging, not set yet - don't include.
   var size = polygon.GetSize();
   if( size < 2 )
     return;
      
   var distance = 0.0;
   var point = null;     /* GlgObject */
   for( var i=0; i<size; ++i )
   {
      var last_point = point;    /* GlgObject */
      point = polygon.GetElement( i );
            
      if( last_point != null )
        // Nautical mile = 1842m 
        distance += GetGlobeDistance( point, last_point ) / 1842.0;
   }
      
   Map.SetDResource( "DistancePopup/Distance", distance );
}
   
//////////////////////////////////////////////////////////////////////////
// Returns the length (in meters) of the shortest arc along the earth 
// surface connecting the two points.
//////////////////////////////////////////////////////////////////////////
function GetGlobeDistance( /* GlgObject */ point1_obj,
                           /* GlgObject */ point2_obj )
{
   var lat_lon1, lat_lon2, globe_point1, globe_point2;   /* GlgPoint */
   
   lat_lon1 = point1_obj.GetGResource( null );
   lat_lon2 = point2_obj.GetGResource( null );
      
   // XYZ of the first point, in meters.
   globe_point1 = GetPointXYZ( lat_lon1 );
      
   // XYZ of the second point, in meters.
   globe_point2 = GetPointXYZ( lat_lon2 );
      
   var dx = globe_point1.x - globe_point2.x;
   var dy = globe_point1.y - globe_point2.y;
   var dz = globe_point1.z - globe_point2.z;

   // Length of a straight line between the points.
   var straight_dist = Math.sqrt( dx * dx + dy * dy + dz * dz );
   
   // Use the average value.
   var globe_radius = ( GLG.EQUATOR_RADIUS + GLG.POLAR_RADIUS ) / 2.0;

   // The length of the shortest connecting arc along the earth surface. 
   var arc_dist = 2.0 * globe_radius *
     Math.asin( straight_dist / ( 2.0 * globe_radius ) );
   
   return arc_dist;
}

//////////////////////////////////////////////////////////////////////////
function GetPointXYZ( /* GlgPoint */ lat_lon )     /* GlgPoint */
{
   var
     angle_x,
     angle_y;
   
   var xyz =  GLG.CreateGlgPoint( 0, 0, 0 );   /* GlgPoint */

   /* For simplicity, place the origin at the intersection of the x axis 
      with the globe surface. */
   
   angle_x = DegToRad( lat_lon.x );
   angle_y = DegToRad( lat_lon.y );
      
   xyz.x = GLG.EQUATOR_RADIUS * Math.cos( angle_x ) * Math.cos( angle_y );
   xyz.y = GLG.EQUATOR_RADIUS * Math.sin( angle_y );
   xyz.z = GLG.EQUATOR_RADIUS * Math.sin( angle_x ) * Math.cos( angle_y );

   return xyz;
}

//////////////////////////////////////////////////////////////////////////
function Zoom( type, value )
{
   switch( type )
   {
    default:
      if( UseRequest )
      {
         /* Prepare new map image in a separate thread. The requested image
            will be installed using InstallGISRequest when it is ready.
            CheckScrollLimits will be invoked from AdjustRequest, and
            UpdateObjectsOnMap will be invoked when the request is installed.
         */

         Map.RequestGISZoom( null, type, value, gis_request_observer );
         RequestType = type;
      }
      else
      {
         Map.SetZoom( null, type, value );
         RequestType = type;
         
         CheckScrollLimits( null );
         UpdateObjectsOnMap( false );
      }

      SetMapLoading( true, "Loading map..." );
      Drawing.Update();
      break;

    case 'n':
      // Reset map to the initial extent.
      NewMapProjection = GLG.GlgProjectionType.ORTHOGRAPHIC_PROJECTION;
      NewCenter = GLG.CopyGlgPoint( InitCenter );
      NewExtent = GLG.CopyGlgPoint( InitExtent );
      NewFlags = ( GLG.GlgGISRequestFlags.GIS_REQUEST_PROJECTION | 
                   GLG.GlgGISRequestFlags.GIS_REQUEST_CENTER | 
                   GLG.GlgGISRequestFlags.GIS_REQUEST_EXTENT );
      
      RequestNewMap( true, true );
      break;
      
    case 't':
      // Start ZoomTo
      if( UseRequest )
        Map.RequestGISZoom( null, 't', 0.0, gis_request_observer );
      else
        Map.SetZoom( null, 't', 0.0 );
      
      SetStatus( "Define a rectangular area to zoom to." );
      Drawing.Update();	 
      break;
      
    case 's':
      // Start dragging the map with the mouse
      if( UseRequest )
        Map.RequestGISZoom( null, 's', 0.0, gis_request_observer );
      else
        Map.SetZoom( null, 's', 0.0 );
      
      Drawing.Update();	 
      break;
   }
}

//////////////////////////////////////////////////////////////////////////
function RequestNewMap( /* boolean */ update_objects, /* boolean */ call_update )
{
   if( NewFlags == 0 )
     return;   // No change
   
   if( UseRequest )
   {
      /* Prepare new map image in a separate thread. The requested image
         will be installed using InstallGISRequest when it is ready.
         StoreNewValues and UpdateObjectsOnMap will be invoked when the 
         request is installed.
      */
      GISObject.RequestGISMap( null, NewExtent.x, NewExtent.y, 
                               NewCenter.x, NewCenter.y, 0, NewMapProjection, 
                               NewLayers, NewFlags, gis_request_observer );
      NewFlags = 0;
   }
   else   /* Set GIS object parameters directly and let it load the map. */
   {
      if( ( NewFlags & GLG.GlgGISRequestFlags.GIS_REQUEST_PROJECTION ) != 0 )
        GISObject.SetDResource( "GISProjection", NewMapProjection );
      if( ( NewFlags & GLG.GlgGISRequestFlags.GIS_REQUEST_EXTENT ) != 0 )
        GISObject.SetGResourceFromPoint( "GISExtent", NewExtent );
      if( ( NewFlags & GLG.GlgGISRequestFlags.GIS_REQUEST_CENTER ) != 0 )
        GISObject.SetGResourceFromPoint( "GISCenter", NewCenter );
      if( ( NewFlags & GLG.GlgGISRequestFlags.GIS_REQUEST_LAYERS ) != 0 )
        GISObject.SetSResource( "GISLayers", NewLayers );
      NewFlags = 0;
      
      StoreNewValues();

      if( update_objects )
        UpdateObjectsOnMap( false );
      if( call_update )
        Drawing.Update();
   }

   SetMapLoading( true, "Loading map..." );
}
  
//////////////////////////////////////////////////////////////////////////
function StoreNewValues()
{
   if( NewBaseLayers != null )
   {
      BaseLayers = NewBaseLayers;
      NewBaseLayers = null;
   }
   
   if( NewCityLabelsFlag )
   {
      CityLabels = NewCityLabels;
      NewCityLabelsFlag = false;
   }
   
   // Store a possibly changed projection.
   MapProjection = Math.trunc( GISObject.GetDResource( "GISProjection" ) );
}

//////////////////////////////////////////////////////////////////////////
// For rectangular projection on the detailed map, make sure the map 
// does not scroll beyond the poles in the vertical direction.
//////////////////////////////////////////////////////////////////////////
function CheckScrollLimits( request_data )
{
   var extent, center;       /* GlgPoint */
   var min_y, max_y;         /* double */
   var adjust_x, adjust_y;   /* boolean */
      
   /* Since CheckScrollLimits may be invoked with null request data in 
      non-request mode (USE_REQUEST=false), we can't use request_data.flags
      to determine request type. Instead, the RequestType variable 
      is used to indicate request type for both modes.
   */
   var type = RequestType;
   RequestType = null;

   switch( type )
   {
    case 'u':  // Scroll up
    case 'd':  // Scroll down
    case 'l':  // Scroll left
    case 'r':  // Scroll right
      break; // Adjust only for scroll types.
    default: return;   // Don't adjust for other zoom types.
   }
      
   var projection = GetMapProjection( request_data );
   if( projection == GLG.GlgProjectionType.ORTHOGRAPHIC_PROJECTION )
     return;   // Allow unlimited scrolling for ortho.
      
   extent = GetMapExtent( request_data );
   center = GetMapCenter( request_data );

   min_y = center.y - extent.y / 2.0;
   max_y = center.y + extent.y / 2.0;
   
   /* Check and adjust center lat to make sure the map does not scroll 
      beyond the poles in the vertical direction. 
   */
   adjust_y = true;
   if( extent.y >= 180.0 )
     center.y = 0.0;
   else if( min_y < -90.0 )
     center.y = -90.0 + extent.y / 2.0;
   else if( max_y > 90.0 )
     center.y = 90.0 - extent.y / 2.0;
   else
     adjust_y = false;
   
   /* Allow scrolling to +-180 in horizontal direction, to match the
      range of the horizontal scrollbar.
   */
   adjust_x = true;
   if( center.x < -180.0 )
     center.x = -180.0;
   else if( center.x > 180.0 )
     center.x = 180.0;
   else
     adjust_x = false;
   
   /* Set adjusted center. If called from AdjustRequest, it's already
      modified in-place in request_data - do nothing.
   */
   if( request_data == null && ( adjust_x != 0 || adjust_y != 0 ) )
     GISObject.SetGResourceFromPoint( "GISCenter", center );
}

////////////////////////////////////////////////////////////////////////
// Changes plane color to indicate selection and displayes or erases the 
// flight info popup dialog.
////////////////////////////////////////////////////////////////////////
function SelectPlane( selected_plane_index )
{
   var plane;              /* PlaneData */
   var popup_visibility;   /* double */
      
   if( SelectedPlaneIndex != -1 )   // Unselect previously selected plane
   {
      plane = PlaneArray[ SelectedPlaneIndex ];
      if( plane.graphics != null )    // Restore color if plane is visible 
        plane.graphics.SetDResource( "ColorIndex", plane.color_index );
   }
      
   if( selected_plane_index != -1 )   // Select new plane
   {
      plane = PlaneArray[ selected_plane_index ];
      if( plane.graphics != null ) // Set selected color if plane is visible
        plane.graphics.SetDResource( "ColorIndex", SELECTED );
   }
   
   // Display or erase the flight info popup.
   if( selected_plane_index == -1 )    // Unselected
     popup_visibility = 0.0;
   else   // Selected
     popup_visibility = 1.0;
   FlightInfoPopup.SetDResource( "Visibility", popup_visibility );
   
   SelectedPlaneIndex = selected_plane_index;
}

////////////////////////////////////////////////////////////////////////
function DisplayPlaneInfo()
{
   var plane = PlaneArray[ SelectedPlaneIndex ];    /* PlaneData */
   FlightInfoPopup.SetSResource( "FlightInfo", plane.tooltip );
   FlightInfoPopup.SetDResource( "Elevation", GetPlaneElevation( plane ) );
   FlightInfoPopup.SetDResource( "StatusIndex", plane.color_index );
   
   FlightInfoPopup.SetSResource( "Location",
                                 CreateLocationString( plane.lat_lon ) );
}
   
////////////////////////////////////////////////////////////////////////
// Delete node icons and place them into the object pool. 
////////////////////////////////////////////////////////////////////////
function DeleteNodes()
{
   var i;

   // Move node icons into the object pool. 
   var size = NodeGroup.GetSize();
   for( i=0; i<size; ++i )
   {
      var icon = NodeGroup.GetElement( i );     /* GlgObject */
      NodePool[ NodeType ].AddObjectToBottom( icon );
   }

   // Delete node icons from the drawing and node group 
   GISObject.DeleteThisObject( NodeGroup );
   for( i=0; i<size; ++i )
     NodeGroup.DeleteBottomObject();
      
   // Set nodes' graphics to null 
   if( size > 0 )
     for( i=0; i<NumNodes; ++i )
       NodeArray[i].graphics = null;
}

////////////////////////////////////////////////////////////////////////
// Delete plane icons and place them into the object pool. 
////////////////////////////////////////////////////////////////////////
function DeletePlanes()
{
   var i;
          
   // Move plane icons into the object pool.
   var size = PlaneGroup.GetSize();
   for( i=0; i<size; ++i )
   {
      var icon = PlaneGroup.GetElement( i );   /* GlgObject */
      PlanePool[ PlaneType ].AddObjectToBottom( icon );
   }
   
   // Delete plane icons from the drawing and plane group 
   GISObject.DeleteThisObject( PlaneGroup );
   for( i=0; i<size; ++i )
     PlaneGroup.DeleteBottomObject();
   
   // Set planes' graphics to null 
   if( size > 0 )
     for( i=0; i<NumPlanes; ++i )
       PlaneArray[i].graphics = null;
   
   DeleteTrajectories();
}

////////////////////////////////////////////////////////////////////////
// Delete trajectory objects and place them into the object pool. 
////////////////////////////////////////////////////////////////////////
function DeleteTrajectories()
{
   var i;

   // Move plane icons into the object pool.
   var size = TrajectoryGroup.GetSize();
   for( i=0; i<size; ++i )
   {	
      var icon = TrajectoryGroup.GetElement( i );   /* GlgObject */
      TrajectoryPool.AddObjectToBottom( icon );
   }
      
   // Delete trajectory icons from the drawing and trajectory group
   GISObject.DeleteThisObject( TrajectoryGroup );
   for( i=0; i<size; ++i )
     TrajectoryGroup.DeleteBottomObject();
   
   // Set trajectorys' graphics to null
   if( size > 0 )
     for( i=0; i<NumPlanes; ++i )
       PlaneArray[i].trajectory = null;
}

////////////////////////////////////////////////////////////////////////
function PositionNode( /* NodeData */ node, index )
{
   if( !IconVisible( node.lat_lon ) )
     return;
   
   // Add node's graphics to the drawing if first time.
   if( node.graphics == null )
     AddNodeGraphics( node, NodeType, index );
   
   /* Position node's icon. Since the icons are added as children of the 
      GIS Object, their coordinates are specified in lat/lon. The GIS Object
      handles all details of coordinate convesion.
   */
   node.graphics.SetGResourceFromPoint( "Position", node.lat_lon );
}

////////////////////////////////////////////////////////////////////////
function CreateNodeIcon( /* int */ node_type )
{
   var icon;      /* GlgObject */
      
   var size = NodePool[ node_type ].GetSize();
   if( size > 0 )   // Return an icon from the pool
   {
      icon = NodePool[ node_type ].GetElement( size - 1 );
      NodePool[ node_type ].DeleteBottomObject();
   }
   else   // Create a new icon
   {
      icon =
        NodeTemplate[ node_type ].CloneObject( GLG.GlgCloneType.STRONG_CLONE );
   }
   return icon;
}
   
////////////////////////////////////////////////////////////////////////
function CreatePlaneIcon( /* int */ plane_type )
{
   var icon;   /* GlgObject */

   var size = PlanePool[ plane_type ].GetSize();
   if( size > 0 )   // Return an icon from the pool
   {
      icon = PlanePool[ plane_type ].GetElement( size - 1 );
      PlanePool[ plane_type ].DeleteBottomObject();
   }
   else   // Create a new icon 
   {
      icon = 
        PlaneTemplate[ plane_type ].CloneObject( GLG.GlgCloneType.STRONG_CLONE );
   }
   return icon;
}

////////////////////////////////////////////////////////////////////////
function CreateTrajectoryIcon()   /* GlgObject */
{
   var icon;   /* GlgObject */
   
   var size = TrajectoryPool.GetSize();
   if( size > 0 )   // Return an icon from the pool
   {
      icon = TrajectoryPool.GetElement( size - 1 );
      TrajectoryPool.DeleteBottomObject();
   }
   else   // Create a new icon 
   {
      icon = TrajectoryTemplate.CloneObject( GLG.GlgCloneType.STRONG_CLONE );
   }
   return icon;
}

////////////////////////////////////////////////////////////////////////
function PositionPlane( /* PlaneData */ plane, index )
{
   // Gets the new plane's position, simulated or from real data.
   GetPlaneLatLon( plane );
   
   if( !IconVisible( plane.lat_lon ) )
   {
      // Delete graphics and place into the pool
      if( plane.graphics != null )
      {
         PlanePool[ PlaneType ].AddObjectToBottom( plane.graphics );
         PlaneGroup.DeleteThisObject( plane.graphics );
         plane.graphics = null;
      }

      // Delete trajectory and place into the pool
      if( plane.trajectory != null )
      {
         TrajectoryPool.AddObjectToBottom( plane.trajectory );
         TrajectoryGroup.DeleteThisObject( plane.trajectory );
         plane.trajectory = null;
      }
      return;
   }
   
   // Add the plane icon to the drawing if the first time.
   if( plane.graphics == null  )
     AddPlaneGraphics( plane, PlaneType, index );

   /* Position plane's icon. Since the icons are added as children of the 
      GIS Object, their coordinates are specified in lat/lon. The GIS Object
      handles all details of coordinate convesion.
   */
   plane.graphics.SetGResourceFromPoint( "Position", plane.lat_lon );
      
   // Update icon's direction angle if necessary.
   if( HasAngle )
     plane.graphics.SetDResource( "Angle", GetPlaneAngle( plane ) );

   if( HasElevation )
     plane.graphics.SetDResource( "Height", GetPlaneElevation( plane ) );
   
   if( plane.trajectory != null )
   {
      /* For small speeds, skip a few iterations to increase the 
         trajectory's length.
      */
      if( PlaneSpeed < 0.01 )  
      {
         var n = Math.trunc( 0.01 / PlaneSpeed );
         if( n != 0 )
         {
            ++plane.iteration;
            if( ( plane.iteration % n ) != 0 )
              return;   // Skip n iterations, update every n'th
         }
      }      
      
      plane.trajectory.SetDResource( "VisEntryPoint", 1.0 );
      plane.trajectory.SetGResourceFromPoint( "XYEntryPoint", plane.lat_lon );
   }
}

////////////////////////////////////////////////////////////////////////
// Adds an airport icon, fills labels, tooltips, etc.
////////////////////////////////////////////////////////////////////////
function AddNodeGraphics( /* NodeData */ node, /* int */ node_type, index )
{      
   var icon = CreateNodeIcon( node_type );    /* GlgObject */
      
   // Index for direct access 
   icon.SetDResource( "DataIndex", index );
      
   if( node_type > 0 )   // More detailed icon
     icon.SetSResource( "LabelString", node.name );
      
   var tooltip = node.name + ", " + CreateLocationString( node.lat_lon );
   icon.SetSResource( "TooltipString", tooltip );
      
   node.graphics = icon;
      
   // The node will be positioned after the GIS object is setup.
      
   NodeGroup.AddObjectToBottom( icon );
}

////////////////////////////////////////////////////////////////////////
// Adds a plane icon, fills labels, tooltips, etc.
////////////////////////////////////////////////////////////////////////
function AddPlaneGraphics( /* PlaneData */ plane, /* int */ plane_type, index )
{
   var icon = CreatePlaneIcon( plane_type );   /* GlgObject */
      
   // Index for direct access
   icon.SetDResource( "DataIndex", index );
      
   // Icon color
   icon.SetDResource( "ColorIndex", plane.color_index );
      
   if( plane_type > 0 )   // More detailed icon
   {
      // Show the flight number as icon label
      var label = "Flight " + plane.flight_number;
      icon.SetSResource( "LabelString", label );
   }
      
   // Set the tooltip
   icon.SetSResource( "TooltipString", plane.tooltip );
      
   plane.graphics = icon;
   
   PlaneGroup.AddObjectToBottom( icon );
   
   if( plane_type == 2 )   // For detailed icon, create trajectory
   {
      icon = CreateTrajectoryIcon();
      plane.trajectory = icon;
      
      // Set entries invisible initially
      icon.SetDResource( "Marker/Visibility", 0.0 );
         
      TrajectoryGroup.AddObjectToBottom( icon );
         
      for( var i=0; i<NumTrajectoryPoints; ++i )  // Set fading
        icon.SetDResource( "BrightEntryPoint",
                           0.2 + 0.8 * i / NumTrajectoryPoints );
   }
}

////////////////////////////////////////////////////////////////////////
// Check if the icon is visible in the current zoom region.
////////////////////////////////////////////////////////////////////////
function IconVisible( /* GlgPoint */ lat_lon_pos )
{
   // Converts lat/lon to X/Y using GIS object's current projection.
   GISObject.GISConvert( null, GLG.GlgCoordType.OBJECT_COORD,
                         /* Lat/Lon to XY */ false, lat_lon_pos, point );

   return point.z >= 0.0 &&
     point.x > -1100.0 && point.x < 1100.0 &&
     point.y > -1100.0 && point.y < 1100.0;
}

////////////////////////////////////////////////////////////////////////
// Displays a message in the status area.
////////////////////////////////////////////////////////////////////////
function SetStatus( message )
{
   Drawing.SetSResource( "StatusLabel/String", message );
   Drawing.GetResourceObject( "StatusArea" ).Update();
}

////////////////////////////////////////////////////////////////////////
function SetPlaneSize()
{
   for( var i=0; i<NUM_PLANE_TYPES; ++i )
   {
      /* GlgObject */
      var resource = PlaneTemplate[ i ].GetResourceObject( "IconScale" );
      if( resource != null )
      {
         // Polygon icon: set scale.
         resource.SetDResource( null, PlaneSize );
      }
      else
      {
         resource = PlaneTemplate[ i ].GetResourceObject( "Marker/MarkerSize" );
         if( resource != null )
         {
            // Marker: set MarkerSize.
            if( PlaneSize == SMALL_SIZE )
              resource.SetDResource( null, SMALL_MARKER_SIZE );
            else if( PlaneSize == MEDIUM_SIZE )
              resource.SetDResource( null, MEDIUM_MARKER_SIZE );
            else
              resource.SetDResource( null, BIG_MARKER_SIZE );
         }
      }
   }
}

////////////////////////////////////////////////////////////////////////
// Toggle resource between 0 and 1.
////////////////////////////////////////////////////////////////////////
function ToggleResource( /* GlgObject */ obj, res_name )
{
   resource = obj.GetResourceObject( res_name );   /* GlgObject  */
   if( resource == null )
     return;
   
   var value = resource.GetDResource( null );
   resource.SetDResource( null, value != 0.0 ? 0.0 : 1.0 );
}

////////////////////////////////////////////////////////////////////////
function GetMapProjection( /* GlgGISRequestData */ request_data )
{
   if( request_data != null )
     return request_data.projection;
   else
   {
      FlushMapChanges();
      return MapProjection;
   }
}
 
////////////////////////////////////////////////////////////////////////
function GetMapExtent( /* GlgGISRequestData */ request_data )   /* GlgPoint */
{   
   if( request_data != null )
     return request_data.extent;
   else
   {
      FlushMapChanges();
      return GISObject.GetGResource( "GISExtent" );
   }
}

////////////////////////////////////////////////////////////////////////
function GetMapCenter( /* GlgGISRequestData */ request_data )   /* GlgPoint */
{
   if( request_data != null )
     return request_data.center;
   else
   {
      FlushMapChanges();
      return GISObject.GetGResource( "GISCenter" );
   }
}

////////////////////////////////////////////////////////////////////////
function FlushMapChanges()
{
   // Flush new data into the map before querying if the map has changed.
   if( NewFlags != 0 )
     RequestNewMap( false, false );
}

////////////////////////////////////////////////////////////////////////
// Gets extent in lat/lon (converts from meters for ortho projection).
////////////////////////////////////////////////////////////////////////
function GetExtentDegrees( /* GlgGISRequestData */ request_data )  /* GlgPoint */
{   
   var extent = GetMapExtent( request_data );   /* GlgPoint */
   
   var projection = GetMapProjection( request_data );
   if( projection == GLG.GlgProjectionType.ORTHOGRAPHIC_PROJECTION )
   {
      if( request_data != null )
        // Create a copy: will be modified.
        extent = GLG.CopyGlgPoint( extent );
      
      // Convert meters to degrees,
      extent.x = extent.x / GLG.EQUATOR_RADIUS * 90.0;
      extent.y = extent.y / GLG.POLAR_RADIUS * 90.0;
   }
   return extent;
}

//////////////////////////////////////////////////////////////////////////
function RELATIVE_TO_NEW_RANGE( low, high, rel_value )
{
   return ( low + ( high - low ) * rel_value );
}

//////////////////////////////////////////////////////////////////////////
function VALUE_TO_RELATIVE( low, high, value )
{
   return ( high - low != 0.0 ? ( value - low ) / ( high - low ) : 0.0 );
}

//////////////////////////////////////////////////////////////////////////
function DegToRad( angle )
{
   return angle / 180.0 * Math.PI;
}

//////////////////////////////////////////////////////////////////////////
function RadToDeg( angle )
{
   return angle / Math.PI * 180.0;
}

//////////////////////////////////////////////////////////////////////////
// UTILITY FUNCTION: Calculates an angle between the line defined by two 
// points and the X axis.
//////////////////////////////////////////////////////////////////////////
function GetAngle( /* GlgPoint */ pt1, /* GlgPoint */ pt2 )
{
   var length, angle;
      
   length = GetLength( pt1, pt2 );
      
   if( length == 0.0  )
     angle = 0.0;
   else
   {
      angle = Math.acos( ( pt2.x - pt1.x ) / length );
      
      if( pt2.y - pt1.y < 0.0 )  // ScreenSpace Z axis points to the user.
        angle = - angle;
   }
        
   return RadToDeg( angle );
}

//////////////////////////////////////////////////////////////////////////
// UTILITY FUNCTION: Calculates a distance between two points in 2D.
//////////////////////////////////////////////////////////////////////////
function GetLength( /* GlgPoint */ pt1, /* GlgPoint */ pt2 )
{
   return Math.sqrt( ( pt2.x - pt1.x ) * ( pt2.x - pt1.x ) +
                     ( pt2.y - pt1.y ) * ( pt2.y - pt1.y ) );
}

//////////////////////////////////////////////////////////////////////////
// FOR FLIGHT SIMULATION ONLY: Converts plane lat/lon to the GLG world 
//     coordinates for calculating plane speed and directional angle.
//////////////////////////////////////////////////////////////////////////
function GetPlanePosition( /* PlaneData */ plane, /* GlgPoint */ xyz )
{
   // Converts lat/lon to X/Y using GIS object's current projection.
   GISObject.GISConvert( null, GLG.GlgCoordType.OBJECT_COORD, 
                         /* Lat/Lon to XY */ false, plane.lat_lon, xyz );
}

//////////////////////////////////////////////////////////////////////////
// FOR FLIGHT SIMULATION ONLY: Converts node lat/lon to the GLG world 
//     coordinates for calculating plane's initial directional angle.
//////////////////////////////////////////////////////////////////////////
function GetNodePosition( /* NodeData */ node, /* GlgPoint */ xyz )
{
   // Converts lat/lon to X/Y using GIS object's current projection.
   GISObject.GISConvert( null, GLG.GlgCoordType.OBJECT_COORD, 
                         /* Lat/Lon to XY */ false, node.lat_lon, xyz );
}

//////////////////////////////////////////////////////////////////////////
// FOR FLIGHT SIMULATION ONLY: Calculates plane icon's directional angle.
//     In an application, it will query the plane's directional angle.
//////////////////////////////////////////////////////////////////////////
function GetPlaneAngle( /* PlaneData */ plane )
{
   /* Rectangular projection preserves straight lines, we can use the 
      angle of the line connecting the start and end nodes. For the
      orthographic projection, use this case if the plane has just started
      and there is no previous position stored.
   */
   if( MapProjection == GLG.GlgProjectionType.RECTANGULAR_PROJECTION ||
       plane.path_position == plane.path_position_last )   // Just started
   {
      GetNodePosition( plane.from_node, last_xyz );
      GetNodePosition( plane.to_node, curr_xyz );
   }
   else  /* In the orthographic projection straight lines are drawn as 
            curves. Use the angle of the line connecting the current and 
            last position of the plane. */
   {
      var stored_position;
      
      stored_position = plane.path_position;    // Store current position.
      
      // Get coordinates of the plane's previous position
      plane.path_position = plane.path_position_last;
      GetPlaneLatLon( plane );
      GetPlanePosition( plane, last_xyz );
      
      // Restore the plane's current position and get its coordinates.
      plane.path_position = stored_position;
      GetPlaneLatLon( plane );
      GetPlanePosition( plane, curr_xyz );
   }
   
   /* Calculate the angle of a line connecting the previous and 
      current position.
   */
   return GetAngle( last_xyz, curr_xyz );
}

////////////////////////////////////////////////////////////////////////
// FOR FLIGHT SIMULATION ONLY: Calculates plane icon's elevation.
//     In an application, it will query the plane elevation.
//
// For the simulation, it calculated the elevation using zero at the start
// and end of the path and the maximum elevation in the middle.
////////////////////////////////////////////////////////////////////////
function GetPlaneElevation( /* PlaneData */ plane )
{
   return ( 0.5 - Math.abs( plane.path_position - 0.5 ) ) * 2.0 * 10000.0;   
}

////////////////////////////////////////////////////////////////////////
// Updates moving icons with the new position data.
////////////////////////////////////////////////////////////////////////
function UpdatePlanes()
{
   /* If UseRequest=true, the map loading message will be erased when the 
      request is installed.
   */
   if( ( InitialLoad || !UseRequest && !MapLoaded ) &&
       Math.trunc( GISObject.GetDResource( "ImageLoaded" ) ) != 0 )
   {
      SetMapLoading( false, "" );
      InitialLoad = false;
   }
   
   if( PerformUpdates )
   {     
      for( var i = 0; i < NumPlanes; ++i )
        UpdatePlane( PlaneArray[ i ], i );
      
      if( SelectedPlaneIndex != -1 )   // Update selected plane info if any 
        DisplayPlaneInfo();
      
      Drawing.Update();
   }
   
   // Restart update timer.
   timer = setTimeout( UpdatePlanes, UpdateInterval );
}

////////////////////////////////////////////////////////////////////////
// FOR FLIGHT SIMULATION ONLY: Calculates new plane position using 
// simulated data. In an application, it will query the plane's lat/lon.
////////////////////////////////////////////////////////////////////////
function UpdatePlane( /* PlaneData */ plane, index )
{      
   if( plane.from_node == null || plane.to_node == null )
     return;    // Plane is not in the air - no start/destination node.
   
   // Finished the old path, start a new one.
   if( plane.path_position == 1.0 )
   {
      if( index == SelectedPlaneIndex )
        SelectPlane( -1 );   // Unselect the plane: it reached destination
      
      StartPlane( plane, false );
   }
   else  // Continue on the current path.
   {
      var speed = PlaneSpeed;
      
      // Store last position for calculating angle in ORTHO projection. 
      plane.path_position_last = plane.path_position;
      
      plane.path_position += plane.speed * speed;
      if( plane.path_position > 1.0 )
        plane.path_position = 1.0;
   }

   SetPlaneColor( plane );
   
   PositionPlane( plane, index );   // Position plane on the map
}

////////////////////////////////////////////////////////////////////////
// FOR FLIGHT SIMULATION ONLY: Simulate data to change plane color to show 
//     warnings and alarms. In an application, it will query the plane's 
//     status.
////////////////////////////////////////////////////////////////////////
function SetPlaneColor( /* PlaneData */ plane )
{
   var new_color_index = NORMAL;

   // Set random color
   var random_value = GLG.Rand( 0.0, 1.0 );
   if( plane.color_index == NORMAL )
   {
      if( random_value <= 0.999 )
        new_color_index = NORMAL;
      else if( random_value > 0.9999 )
        new_color_index = ALARM;
      else if( random_value > 0.999 )
        new_color_index = WARNING;     
   }
   else if( plane.color_index == WARNING )
   {
      if( random_value > 0.99 )
        new_color_index = NORMAL;
      else
        new_color_index = plane.color_index;   // Keep alarm for a while
   }
   else if( plane.color_index == ALARM )
   {
      if( random_value > 0.999 )
        new_color_index = NORMAL;
      else
        new_color_index = plane.color_index;   // Keep alarm for a while
   }
   
   if( plane.graphics != null && 
       new_color_index != plane.color_index )
     plane.graphics.SetDResource( "ColorIndex", new_color_index );
   
   plane.color_index = new_color_index;
}

////////////////////////////////////////////////////////////////////////
// FOR FLIGHT SIMULATION ONLY: Starts simulation for a plane, selects its 
// start and end nodes. 
////////////////////////////////////////////////////////////////////////
function StartPlane( /* PlaneData */ plane, /* boolean */ init )
{
   var
     to_index,
     from_index;
      
   if( NumNodes < 2 )
     alert( "Less then two nodes: can't start planes." );

   from_index = Math.trunc( GLG.Rand( 0.0, NumNodes - 0.001 ) );
   do
   {
      to_index = Math.trunc( GLG.Rand( 0.0, NumNodes - 0.001 ) );
   } while( to_index == from_index );

   plane.from_node = NodeArray[ from_index ];
   plane.to_node = NodeArray[ to_index ];
   plane.flight_number = Math.trunc( GLG.Rand( 101.0, 1999.0 ) );
   plane.speed = GLG.Rand( 0.4, 1.0 );   // Vary plane speed 
      
   if( init )   // Init the demo: position randomly along the path 
   {
      plane.path_position = GLG.Rand( 0.1, 0.9 );
      plane.path_position_last = plane.path_position - 0.05;  // For angle
   }
   else         // Position at the beginning of the path 
   {
      plane.path_position = 0.0;
      plane.path_position_last = 0.0;
   }
   
   var flight_name = "Flight " + plane.flight_number;
      
   // Add from/to node info to the tooltip.
   plane.tooltip = flight_name + " from "  +
     plane.from_node.name + " to " +  plane.to_node.name;

   // Set all trajectory points invisible, if any 
   if( plane.trajectory != null )
     plane.trajectory.SetDResource( "Marker%/Visibility", 0.0 );
}

////////////////////////////////////////////////////////////////////////
// FOR FLIGHT SIMULATION ONLY: Calculates plane's lat/lon using simulated 
//     data. In an application, it will query the plane's position.
//
// The simulation moves the plane from the start to the end node/city
// as controlled by the path_position parameter. The path_position changes
// in the range from from 0 (start node) to 1 (end node).
////////////////////////////////////////////////////////////////////////
function GetPlaneLatLon( /* PlaneData */ plane )
{
   plane.lat_lon.x = 
     RELATIVE_TO_NEW_RANGE( plane.from_node.lat_lon.x, 
                            plane.to_node.lat_lon.x, plane.path_position );
   plane.lat_lon.y = 
     RELATIVE_TO_NEW_RANGE( plane.from_node.lat_lon.y, 
                            plane.to_node.lat_lon.y, plane.path_position );
}

//////////////////////////////////////////////////////////////////////////
// Generate a location info string by converting +- sign info into the
// N/S, E/W suffixes, and decimal fraction to deg, min, sec.
//////////////////////////////////////////////////////////////////////////
function CreateLocationString( /* GlgPoint */ point )   /* String */
{
   var x_deg, y_deg, x_min, y_min, x_sec, y_sec;  /* int */
   var char_x, char_y;  /* String */
   var lat, lon;        /* double */

   if( point.z < 0.0 )
     return "";

   lon = point.x;
   lat = point.y;
   
   if( lon < 0.0 )
   {
      lon = -lon;
      char_x = 'W';
   }
   else if( lon >= 360.0 )
   {
      lon -= 360.0;
      char_x = 'E';
   }
   else if( lon >= 180.0 )
   {
      lon = 180.0 - ( lon - 180.0 );
      char_x = 'W';
   }
   else
     char_x = 'E';
   
   if( lat < 0.0 )
   {
      lat = -lat;
      char_y = 'S';
   }
   else
     char_y = 'N';
   
   x_deg = Math.trunc( lon );
   x_min = Math.trunc( ( lon - x_deg ) * 60.0 );
   x_sec = Math.trunc( ( lon - x_deg - x_min / 60.0 ) * 3600.0 );
   
   y_deg = Math.trunc( lat );
   y_min = Math.trunc( ( lat - y_deg ) * 60.0 );
   y_sec = Math.trunc( ( lat - y_deg - y_min / 60.0 ) * 3600.0 );
   
   var location_string =
     "Lon=" + x_deg + "\u00B0" + 
          GLG.PrintfI( "%02d", x_min ) + "'" + 
          GLG.PrintfI( "%02d", x_sec ) + '"' + char_x +
     "  Lat=" + y_deg + "\u00B0" + 
          GLG.PrintfI( "%02d", y_min ) + "'" + 
          GLG.PrintfI( "%02d", y_sec ) + '"' + char_y;
   return location_string;
}

//////////////////////////////////////////////////////////////////////////
// Zoom to the Florida area after a few seconds to show details.
//////////////////////////////////////////////////////////////////////////
function ZoomToFlorida()
{      
   AbortDistanceMode();

   // Show zoom message.
   Drawing.SetDResource( "Map/FloridaZoomingMessage/Visibility", 1.0 );
   Drawing.Update();

   /* GISExtent is in lon/lat for the rectangular GIS projection,
      and in meters for the orthographic projection.
      To find proper values, zoom the map in the GlgBuilder and 
      copy the GISExtent values. */
   
   // Zoom to the Florida boundaries on detailed map.
   NewExtent = GLG.CreateGlgPoint( 1169530.0, 1169530.0, 0.0 );
   NewCenter = GLG.CreateGlgPoint( -82.8239, 28.9382, 0.0 );
   NewFlags = ( GLG.GlgGISRequestFlags.GIS_REQUEST_EXTENT |
                GLG.GlgGISRequestFlags.GIS_REQUEST_CENTER );

   RequestNewMap( true, false );

   /* Reorder Florida zoom message to the top, in case any objects 
      were added on top of it.
   */
   var florida_message =
     Drawing.GetResourceObject( "Map/FloridaZoomingMessage" );
   Map.ReorderElement( Map.GetIndex( florida_message ), Map.GetSize() - 1 );
   Drawing.Update();

   // Erase zoom message after a delay.
   zoom_timer = setTimeout( ZoomToFloridaEnd, FloridaZoomDelay2 );
}

//////////////////////////////////////////////////////////////////////////
// Remove the Florida zooming message after a few seconds.
//////////////////////////////////////////////////////////////////////////
function ZoomToFloridaEnd()
{
   Drawing.SetDResource( "Map/FloridaZoomingMessage/Visibility", 0.0 );
   Drawing.Update();
   zoom_timer = null;
}

//////////////////////////////////////////////////////////////////////////
// GIS request observer interface: requests adjustement callbacks.
//////////////////////////////////////////////////////////////////////////
function RequestAdjustment()
{
   return true;
}

//////////////////////////////////////////////////////////////////////////
// GIS request observer interface: adjustement callback.
//////////////////////////////////////////////////////////////////////////
function AdjustRequest( /* GlgGISRequestData */ request_data )
{
   var flags = request_data.flags;

   if( ( flags & GLG.GlgGISRequestFlags.GIS_REQUEST_EXTENT ) != 0 )
   {
      /* Change layers only if zoom changed, to allow user to toggle
         CityLabels.
      */
      SetupZoomLayers( request_data );
      
      if( ( flags & GLG.GlgGISRequestFlags.GIS_REQUEST_CENTER ) != 0 ||
          ( flags & GLG.GlgGISRequestFlags.GIS_REQUEST_PROJECTION ) != 0 )
        CheckScrollLimits( request_data );
   }
   return true;
}

//////////////////////////////////////////////////////////////////////////
// GIS request observer interface: receives status update notifications.
//////////////////////////////////////////////////////////////////////////
function RequestUpdate( /* GlgObject */ gis_object, status )
{
   switch( status )
   {
    case GLG.GlgGISRequestStatus.GIS_REQUEST_READY:
      if( gis_object.InstallGISRequest( null ) )
      {
         StoreNewValues();
         
         UpdateObjectsOnMap( true );
         Drawing.Update();
      }
      else
        SetStatus( "Failed to install map request." );
      break;
      
    default:
      console.log( "Aborting previous GIS request." ); 
      break;
   }

   SetMapLoading( false, "" );
}

//////////////////////////////////////////////////////////////////////////////
// Loads any assets required by the application and invokes the specified
// callback when done.
// Alternatively, the application's drawing can be loaded as an asset here
// as well, so that it starts loading without waiting for other assets to
// finish loading.
//////////////////////////////////////////////////////////////////////////////
function LoadAssets( callback )
{
   /* HTML5 doesn't provide a scrollbar input element (only a range input 
      html element is available). This application needs to load GLG scrollbars
      used for integrated chart scrolling. For each loaded scrollbar, the 
      AssetLoaded callback is invoked with the supplied data.
   */
   GLG.LoadWidgetFromURL( "scrollbar_h.g", null, AssetLoaded,
                          { name: "scrollbar_h", callback: callback } );
   GLG.LoadWidgetFromURL( "scrollbar_v.g", null, AssetLoaded,
                          { name: "scrollbar_v", callback: callback } );
}

//////////////////////////////////////////////////////////////////////////////
function AssetLoaded( glg_object, data, path )
{
   if( data.name == "scrollbar_h" )
   {
      if( glg_object != null )
        glg_object.SetResourceObject( "$config/GlgHScrollbar", glg_object );
   }
   else if( data.name == "scrollbar_v" )
   {
      if( glg_object != null )
        glg_object.SetResourceObject( "$config/GlgVScrollbar", glg_object );
   }
   else
     console.error( "Unexpected asset name" );

   /* Define an internal variable to keep the number of loaded assets. */
   if( AssetLoaded.num_loaded == undefined )
     AssetLoaded.num_loaded = 1;
   else
     ++AssetLoaded.num_loaded;

   // Invoke the callback after all assets have been loaded.
   if( AssetLoaded.num_loaded == 2 )
     data.callback();
}

//////////////////////////////////////////////////////////////////////////////
// Changes drawing size while maintaining width/height aspect ratio.
//////////////////////////////////////////////////////////////////////////////
function SetDrawingSize( next_size )
{
   const ASPECT_RATIO = 750 / 600;

   // Settings for desktop displays.
   const MIN_WIDTH = 600;
   const MAX_WIDTH = 1000;
   const SCROLLBAR_WIDTH = 15;
   
   if( SetDrawingSize.size_index == undefined )   // first time
   {
      SetDrawingSize.size_index = 0;

      SetDrawingSize.small_sizes       = [ 1, 1.5,  2.,   2.5 ];
      SetDrawingSize.medium_sizes      = [ 1, 0.75, 1.25, 1.5 ];
      SetDrawingSize.large_sizes       = [ 1, 0.6,  1.25, 1.5 ];
      SetDrawingSize.num_sizes = SetDrawingSize.small_sizes.length;
      SetDrawingSize.is_mobile = ( screen.width <= 760 );

      window.addEventListener( "resize", ()=>SetDrawingSize( false ) );
   }
   else if( next_size )
   {
      ++SetDrawingSize.size_index;
      SetDrawingSize.size_index %= SetDrawingSize.num_sizes;
   }

   var drawing_area = document.getElementById( "glg_area" );
   if( SetDrawingSize.is_mobile )
   {
      /* Mobile devices use constant device-width, adjust only the height 
         of the drawing to keep the aspect ratio.
      */
      drawing_area.style.height =
        "" + Math.trunc( drawing_area.clientWidth / ASPECT_RATIO ) + "px";
   }
   else   /* Desktop */
   {
      var span = document.body.clientWidth; 
      if( !SetDrawingSize.is_mobile )
        span -= SCROLLBAR_WIDTH;
      
      var start_width;
      if( span < MIN_WIDTH )
        start_width = MIN_WIDTH;
      else if( span > MAX_WIDTH )
        start_width = MAX_WIDTH;
      else
        start_width = span;
      
      var size_array;
      if( span < 600 )
        size_array = SetDrawingSize.small_sizes;
      else if( span < 800 )
        size_array = SetDrawingSize.medium_sizes;
      else
        size_array = SetDrawingSize.large_sizes;
      
      var size_coeff = size_array[ SetDrawingSize.size_index ];
      var width = Math.trunc( Math.max( start_width * size_coeff, MIN_WIDTH ) );
      
      drawing_area.style.width = "" + width + "px";
      drawing_area.style.height = "" + Math.trunc( width / ASPECT_RATIO ) + "px";
   }
}

//////////////////////////////////////////////////////////////////////////////
// Increases canvas resolution for mobile devices with HiDPI displays.
// Returns chosen coordinate scale factor.
//////////////////////////////////////////////////////////////////////////////
function SetCanvasResolution()
{
   // Set canvas resolution only for mobile devices with devicePixelRatio != 1.
   if( window.devicePixelRatio == 1. || !SetDrawingSize.is_mobile )
   {
      ScrollMode = true;  // Init to true for desktop.
      return 1.0;         // Use coord scale = 1.0 for desktop.
   }

   ScrollMode = false;    // Init to false for mobile devices.

   // Show touch action selector for mobile devices.
   ShowElement( "touch_action", "inline-block" );

   // Mobile devices use fixed device-width: disable Change Drawing Size button.
   RemoveElement( "change_size" );

   /* The first parameter defines canvas coordinate scaling with values 
      between 1 and devicePixelRatio. Values greater than 1 increase 
      canvas resolution and result in sharper rendering. The value of 
      devicePixelRatio may be used for very crisp rendering with very thin lines.

      Canvas scale > 1 makes text smaller, and the second parameter defines
      the text scaling factor used to increase text size.

      The third parameter defines the scaling factor that is used to
      scale down text in native widgets (such as native buttons, toggles, etc.)
      to match the scale of the drawing.
   */
   var coord_scale = 2.0;
   GLG.SetCanvasScale( coord_scale, 1.3, 0.6 );
   
   return coord_scale;      // Chosen coord scale for mobile devices.
}

//////////////////////////////////////////////////////////////////////////
function RemoveElement( name )
{
   var element = document.getElementById( name );
   if( element != null )
     element.parentNode.removeChild( element );
}

//////////////////////////////////////////////////////////////////////////
function ShowElement( name, state )
{
   var element = document.getElementById( name );
   if( element != null )
     element.style.display = state;
}

//////////////////////////////////////////////////////////////////////////////
// Changes action to be performed on touch move on mobile devices.
//////////////////////////////////////////////////////////////////////////////
function SetTouchAction()
{
   var scroll_mode_elem = document.getElementById( "scroll_mode" );
   ScrollMode = scroll_mode_elem.checked;
}

function NodeData( name, lon, lat )
{
   this.name = name;      /* String */
   this.lat_lon = GLG.CreateGlgPoint( lon, lat, 0 );   /* GlgPoint */
   this.graphics = null;  /* GlgObject */
}
   
function PlaneData()
{
   this.name;                   /* String */
   this.lat_lon = GLG.CreateGlgPoint( 0, 0, 0 ); /* GlgPoint */
   this.flight_number = 0;      /* int */
   this.tooltip = null;         /* String */
   this.graphics = null;        /* GlgObject */
   this.trajectory = null;      /* GlgObject */
   this.from_node = null;       /* NodeData */
   this.to_node = null;         /* NodeData */
   this.path_position = 0;      /* double */
   this.path_position_last = 0; /* double */
   this.speed = 0;              /* double */
   this.color_index = 0;        /* int */
   this.iteration = 0;          /* int */
}
